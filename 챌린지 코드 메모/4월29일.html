[4월29일]

++ #.4.0 Input Values

이제 앱을 한번 만들어보자. 
CSS랑 JS 완전히 지우고 시작하자
먼저 유저에게 정보를 물어야한다. 그 다음에 그 정보들을 어떻게 받을지에 대해 배울 것이다.
왜냐면 우리는 아직 그 정보들을 어떻게 받는지 모르기 때문이다.
받은 정보를 화면에 표시할거다.
아직 해보지 않은 작업이니까 중요하다.

JS에는 value를 기억하게 하는 아주 쉬운 방법이 있다.
User의 이름을 기억하는 것처럼.
하지만 모든것은 HTML에서 시작되어야 한다.
우선 HTML을 작성한 다음에 거기 있는 element들을 끌고 오는 것이다.
그런 다음 JS에서 이런저런 작업을 해주는 것.

Input을 생성하는 것부터 시작하자.
본격적으로 시작하기 전에 이번에 만드는 것은 굉장히 못생겨보일 것이다.
못생긴걸 만든 다음에 이쁘게 꾸며주는 작업을 할 것이다.
HTML에 input을 만들어 주었다.

이제 버튼을 만들어 줄 것이다. 버튼은 Log in이라고 적혀있을거고.
근데 이 앱에는 input과 button이 아주 많을 것이다.
예를 들면, 유저의 이름을 입력할 input이 있어야 하고
To-do를 입력할 input도 필요하겠지. 그러니 이름을 더 잘 지을 필요가 있다.

input과 로그인 버튼을 div안에 집어넣어줄 것이다.
그리고 div에 form이란 class를 추가해 줄 것이다.
이제 <div id=“login-form”> 안에서 input이랑 button을 찾을 수 있다.
이걸 JS에서 또 해보자

querySelector()을 사용할 때는 대상이 id인지 명확히 해줘야 한다.
왜냐면 querySlector()로는 classname,tagname 모두 검색 가능하기 때문이다.
근데 getElementByld()를 사용할 때는 그럴 필요 없다. 왜냐면 JS가 id를 찾고 있다는 걸 이미 알고 있기 때문이다.

이제 하려는건 input이랑 button을 끌어오는 것이다.
그 중 하나 보자면 const loginInput을 작성한 다음 document에서 찾는 대신 위에 작성한 loginForm에서 검색하는 것이다.
우선 우리는 HTML에서 form을 찾고 있다. document.getElementById()를 통해서 말이다.
JS가 이걸 찾았다면 loginForm은 HTML내에 있는 element라는 뜻이다. 

이 element들을 JS로 끌고 온 것이다.
다음으로 할 일은 input과 button을 찾는 일인데 우리는 이제 이걸 document가 아닌 LoginForm안에서 바로 찾을 수 있다.
보다시피 loginForm은 HTML element이기 때문이다. 그말은 HTML element안을 바로 검색할 수 있다는 뜻이다.

우리는 우선 login-form이라는 id를 찾았고, 그리고 그 안에서 input과 button을 찾았다.
이 코드들을 더 짧게 작성할 수 있는 방법은
첫줄을 지우고 바로 querySlector(“#login-form input/button”)으로 바꾸고
그리고 첫 줄의 코드 앞에 document로 바꾼다.

이렇듯 document 또는 하나의 element를 통해 검색이 가능하다. 오직 한 element안에서 찾을 수 있다.

우리는 이전에 user가 이 버튼을 클릭할때 감지하는 방법을 배웠었다. 나중에 value를 기록해두기 위해서다.
Click event로.
이 click event는 loginButton에 연결되어야 한다.
function에 이름 붙이는건 본인이 알아보기 쉬운걸로 설정해주면 된다. Btnclick, onloginbtnclick 등등..
자신한테 코드가 더 명확해지는 방향으로 지으면 된다.

이제 loginButton에 대한 click을 감지할 준비가 됐다. 새로운게 아니고 전에 배웠던 것들이다. 복습!

동작 확인.
이제 우린 여기 입력하는 value를 얻고 싶다. 칸 안에 적는 텍스트를 콘솔에 표시하고싶다는 의미이다.
아까 만들어 둔 loginInput을 항상 하듯이 console.dir(loginInput)을 해줄 것이다.
이 후 다시 login버튼을 눌러주면 btnClick()이 실행되면서 logInput의 내부를 보여줄 것이다.
input을 눌러보면 우리가 생성했던 이것저것 들어가 있는 일반적인 object이다.
우리가 해볼건 value다. 기본적으로 input안에 있는 것이다.
HTML에 value를 미리 입력해줄 수도 있다. 입력하고 새로고침하면 박스 안에 value가 선입력 되어있는걸 확인할 수 있다.
이걸로 input의 내용을 가져오려면 어떤 Property를 찾아봐야 하는지 알게됐다.

JS에서 value를 console.log 해보자.
이러고 브라우저에서 콘솔을 확인하면서 버튼을 눌러보면 value가 없는 뭔가를 계속 console.log()하고 있는걸 볼 수 있다.
빈칸에 내용을 적고 버튼을 클릭하면 내용값이 출력되는걸 볼 수 있다.
이런식으로 input의 value를 얻을 수 있다.
근데 문제가 하나 있다. console.log(“hello”,liginInput.value)를 한다고 했을때, 콘솔에 hello랑 value가 표시된다.
여기까지는 좋은데 문제는 아무런 값도 읿력 안했을 때다. 확인해보면 hello 뒤에 아무것도 없는채로 콘솔에 표시되는걸 볼 수 있다.
이 부분에 대한 작업이 필요하다.

Hello뒤에 아무것도 없는 채로 콘솔에 표시되는걸 볼 수 있다. 이건 좋지 않다.
우리는 유저가 이름을 입력했을 때만 버튼을 클릭할 수 있도록 하고 싶어한다.
수많은 if else를 활용해서 뭘 할 수 있을지 살펴보자


++ #4.1 Form Submission

이번엔 username의 유효성을 검사할 것이다. 우선 Username이 비어있으면 안되고, 너무 긴 Username도 안된다. 좀 더 확실하게 하기 위해서다.
매번 loginInput.value를 적는거 대신 우리는 const로 변수로 만들어 줄 것이다.

새로고침하고 클릭하면
Pleas write your name을 출력하는걸 확인할 수 있다. 
이걸 user가 볼 수 있게 alaert로 바꿔주자.

이번엔 else if를 해주고 value를 확인할 거다.
변수명을 username으로 바꾸고 여기서 username이 15글자를 초과하는지 안하는지 확인할 수 있다. 
예를 들자면 말이다. (그냥 확인용) 만약 username이 15글자를 초과한다면 경고창을 보여줄 것이다.

string의 길이를 어떻게 구할 수 있을까? 개발자들이 항상 필요한 것이 있다.
예시로 classname을 제거하거나, 더하거나, string의 길이를 구하는것이다.
이런 이유로 JS에는 이미 우리를 위해 이런 것들이 필요할때 언제든지 공짜로 이용 가능한 장난감들을 가지고 있다.
이번같은 경우에는 username뒤에 .length를 더해줄거다.

이런식으로 string의 길이를 구할 수 있다.
string다음에 .length만 입력해주면 된다. 우리는 15글자 제한을 둘거니까 조건을 추가해준다.
만약 username의 길이가 15보다 길다면, 이름이 너무 길다고 alert해줄 것이다.

만약 유저들을 괴롭히고 싶다면 이름이 너무 짧다고 조건을 추가하면 된다. 
작업을 이렇게 하긴 했지만 좋이는 않다.
JS만으로 작업 시에는 해야만 하는 작업이지만 브라우저 자체의 기능을 사용할 수도 있다. 
지금 이대로도 괜찮긴 한데 항상 user가 입력하는 값의 유효성을 확인하는건 좋은 연습이다.
절대 유저를 믿지마. 절대 믿으면 안돼.

항상 최고의 툴을 사용해야 하고, 이미 가지고 있는 기능들을 사용하는 것이 좋다.
만약 코코아톡 클론 강의를 들었다면 form에 대해 꽤 많은 시간을 들여 공부했다는 것을 알 것이다.
그리고 사실 input은 지금 여기 보이는 것보다 더 많은 일들을 할 수 있다.
예를 들자면 input을 필수입력 항목으로 만들어줄 수 있다.
또는 input 자체적으로 최대 글자수를 15로 조절할 수도 있다.
이런 식으로 할 수 있고, 이건 HTML이 이미 우리를 위해 해주고 있다.

이런 이점을 잘 활용해야한다.
근데 문제는 Log In을 클릭할 때 HTML에서 확인 작업을 안하고 있다. 
그 이유는 div가 form이 아니기 때문이다.
코코아톡 강의를 수강했다면, input의 유효성 검사를 작동시키기 위해서는 input이 form안에 있어야 한다는걸 기억할 것이다.

이렇게.
근데 JS에서 한가지 문제가 발생한다.
일단 작업한 validation은 모두 지우고
username을 아직 받는다는걸 확인하기 위해 console.log(username)만 남겨줄거다.

이제 아주 인상적인 것을 보게될거다.
새로고침을 하고나서 아무런 값도 입력 안할거다.
그대로 로그인을 클릭하면 브라우저가 우릴 돕고 있는걸 볼 수 있다.

우리가 활용할 수 있는건 전부 활용해야지?

긴 값을 입력해보면 최대길이도 적용되고 있는걸 볼 수 있다.
역시나 브라우저가 우릴 돕고 있다. 저 이상으로 입력을 하고 싶어도 할 수가 없다.
문제는 로그인을 클릭하면 URL에 이상한게 따라붙고 있는걸 볼 수 있다. 동시에 페이지가 새로고침되고 있다.
웹사이트를 재시작시키고 있는 것이다. 이렇게 되는 이유는 form이 submit되고 있기 때문이다.
코코아톡 강의를 들었다면 기억할텐데, Input안에 있는 버튼을 누르거나 type이 submit인 input을 클릭하면 submit된다.

그러므로 우리는 이제 더이상 버튼을 클릭하는 것에 신경 쓸 필요가 없다. 
왜냐면 엔터를 눌러도 form은 submit되고있기 때문이다.
이런 규칙들은 HTML을 공부해오며 이미 알고 있는 것들이다.
form안에서 엔터를 누르고 input이 더 존재하지 않는다면 자동으로 submit 된다는 규칙.
또는 form안에 있는 버튼을 눌렀을 때, 이때도 form이 자동으로 submit 된다는 것.
하고싶은 말은 더이상 click에 신경 쓸 필요가 없다는 것이다.
이제 우리의 관심사는 form을 submit 하는 것이다.

HTML의 도움을 활용하려면 이 input을 form 안에 위치시켜야 한다.
그리고 input을 form안에 넣었을 경우에는 우리가 엔터를 누를때마다 form은 자동적으로 submit 되고 있는데
이건 우리가 원하는게 아니다. form이 submit될때마다 페이지가 새로고침되기 때문이다.
웹사이트 전체를 매번 새로고침하고 싶지는 않다.

++ #4.2 Events

우리는 이제 버튼의 클릭여부말고 form의 submit에 관심이 있다.
submit이란 event가 발생하는 걸 아예 막거나 중간에 개입해서
Submit event가 발생했다는걸 파악하고 싶다. 이제 로그인 버튼은 필요없으니 삭제하자.

우리가 지금 필요한건 login-form 그 자체다.

이제 클릭이 아닌 submit을 감지해야한다.
다행히도 우린 submit event가 있다.

이제 form의 submit event를 감지하고 있는데
submit은 엔터를 누르거나 버튼을 클릭할때 발생한다는 것을 기억하도록 한다.

현재 상황..
form을 submit할 때 입력값을 받아내는거고 그건 해낸 상태. 
하지만 아직 새로고침은 못 막고 있다. 새로고침되는건 form submit의 기본 동작이다.
브라우저가 그러도록 프로그래밍 되어 있다. 
브라우저는 로그인 버튼을 누를때도 같은 행동을 하도록 프로그래밍 되어있다.
우리가 해야할 일은 이 기본동작이 발생하지 않도록 하는 것이다.

사실 굉장히 간단하게 할 수 있다. JS가 우리에게 많은 도움을 주기 때문이다.
다시 JS로 돌아가서, EventListener를 추가할 때 우리는 ()을 추가하지 않는다.
왜냐면 ()를 추가하는건 function을 ‘즉시’ 실행한다는 뜻인데 우린 바로 실행되는걸 원하지 않는다.
Submit event가 발생하면 브라우저가 알아서 저 function을 실행시켜줄 것이다. 매우 중요하니 꼭 기억할 것.
() 이것들을 더하면 브라우저가 보자마자 자동으로 이 function을 실행시켜버릴 것이다.
addEventListener를 활용할 때는 바로 실행시키려고 하는게 아니다.
활용할 때는 function의 이름만 적어주고, 그럼 지정한 이벤트가 발생했을때만 해당 function을 실행시킬 것이다. 
그러니까 내가 할 필요 없다.

브라우저가 정확히는 onLoginSubmit()을 하고 있는게 아니다.
브라우저는 우선 OnLoginSubmit function을 호출하고, 브라우저가 function을 실행시키고 있기는 하지만 
()이 안에서 나한테 정보를 주고 있다. (Info)
브라우저는 브라우저 내에서 event로부터 정보를 잡아내서 onLoginSubmit function 실행버튼을 누르고 있다.
나한테 중요할지도 모르는 정보를 가지고 있는 채로 말이다.
argument를 추가해보자. 이름은 뭐가 되든 좋다.
중요한건 event가 발생할 때 브라우저가 내 function을 호출하게 되는데, () 비어있는채로 호출하진 않고
첫번째 argument로써 추가적인 정보를 가진 채로 호출하게 될것이다. onLoginSubmit(xxxxxxx)
어떤 정보를 브라우저가 주고 있는지 보여주기 위해 신기한 코드를 한줄 추가해준다.

브라우저가 우리한테 어떤 정보를 넘겨주는지 확인하고 console.log 해보자.
뭔가 정보를 얻고 있는걸 확인할 수 있다.
onLoginSubmit function에 대한 argument로 말이다.
이 info argument에 포함된 정보로 이것저것 하게 될거니까 이 부분을 제대로 이해하고 넘어가야 한다.
우리가 지금 하고 있는건 onLoginSubmit이라는 function을 만들고 
이 function이 하나의 argument를 받도록 하고 있는 것이다.
지금 저기 적은 function이 하나의 argument를 받도록 하고 그걸 JS에 넘겨주고 있다.

누군가 form을 submit하면 JS가 이 function을 호출하도록 하고 있는 것이다.
JS는 우릴 너무 사랑해서 funtion을 이 상태로 호출하지 않는다.
JS는 여기에서 onLoginSubmit함수의 첫번째 arugument로 발생한 일에 대해 내가 필요로 할만한 정보들을 주는 것이다. 
지금 작성한 코드가 하고 있는 일이다.

모든 EventListener function의 첫번째 argument는 항상 지금 막 벌어진 일들에 대한 정보가 될 것이다. 
JS가 우리에게 이 정보를 무료로 제공한다. 우리는 공간만 제공하면 된다. 
Argument 공간만 제공하면 JS가 알아서 방금 일어난 event에 대한 정보를 지닌 argument를 채워넣을 것이다.

중요한건 여기있는 이 정보가 방금 실행된 event라는 것이다.
여기 있는 것들이 방금 실행된 event에 대한 여러 정보들이다.
예를 들면, submit 주체가 누구인지, 대상은 무엇인지.. 등

preventDefault()는 뭐하는 걸까.
이 function의 기능은 어떤 event의 기본 행동이든지 발생하지 않도록 막는 것이다.
아까 말했듯 기본동작이란 어떤 function에 대해 브라우저가 기본적으로 수행하는 동작이다.
누군가 form을 submit하면 브라우저는 기본적으로 페이지를 새로고침 하도록 되어있다.

이 function을 추가함으로써 그 기본 동작을 막고 있는 것이다.
그리고 이건 EventListener함수의 첫번째 argument 안에 있는 function이다.
EventListener에 어떤 function을 추가하던 간에 JS는 공짜로 첫번째 argument로 발생된 event에 대한 정보를 줄 것이다.
이건 선택사항이다. 필요없다면 그냥 둬도 괜찮다. () 이렇게하면 아무런 정보를 받지 않겠다는거고 (info)이렇게 
공간을 만들어주면 JS에서 event를 채워줄 것이다.
이제 info를 event로 바꿔줄건데 보통 이렇게 작성하는게 관행이다.

이번 강의에서, 우리는 말 그대로 아무것도 안하더라도 아무것도 하지 않음으로써, JS가 어떤 정보를 담은 채로 function을 호출한다는 것을 배웠다. (Event objet를 담은 정보)
그리고 event object는 위위 캡쳐에 있는 것들 말하는거다.
여기엔 기본적으로 제공되는 function이 있는데 그게 바로 preventDefault이다.
이걸 호출하면 브라우저의 기본 동작을 막아줄 것이다.
Submit event가 발생할때 JS는 onLoginSubmit function을 호출하고 있고, 이때 event object를 argument로 주고 있고
기본동작이 실행되는걸 막아주고 있다.
아직 좀 헷갈릴 수 잇다. 이제 가장 기본적인 동작을 막아볼텐데, 그 중  링크를 클릭하는 동작이다.

++ #4.3 Events part II

이번엔 from 관련 내용으로 쉬어가는 코너이다. 어렵기 때문에.
Nomadcoders.co로 연결되는 anchor요소를 하나 만들어 줄 것이다.

반가울 거야. HTML은 이미 알고 있는거니까..
이제 다시한번 JS를 이용해서 기본 동작을 막아볼 것이다. 전에 말했듯이 JS는 우리가 기본동작을 막는걸 허용한다.
전 강의에서 form의 기본동작은 sbumit이라는걸 배웠다.
그럼 링크의 기본동작을 뭘까? 바로 클릭시 다른 페이지로 이동하는 거다. 그걸 막아볼거다.

다시 JS로 돌아와서 링크를 찾아보자.

링크도 하나뿐이고 설명하는 용도니까 이렇게 써도 별 상관없다.
특별히 뭔하 하지 않을 것이다. event를 위한 자리를 만들던가 하는거 말이다. alert만 추가해 줄거다.

alert가 이 페이지가 다른 동작을 하지 못하도록 막고 있다. 아무일도 안 일어나고 있지만 확인을 눌러서 alert가 없어지면 이 브라우저의 기본동작이 실행되는걸 볼 수 있다.
alert는 특이한 애라 모든 동작들을 막는다. 그래서 이제 아무도 alert를 사용하지 않는다.
JS가 EventListener를 만들고 거기에 함수를 줬다는걸 보게되면, JS는 누군가 링크를 클릭할 때, 날 위해 함수를 실행시키게 될거다.
계속 반복해서 말하는 이유는 그만큼 중요하기 때문이다. 
()를 추가하면 이 함수는 한번만 실행되고 그걸로 끝이다. 
나는 JS한테 함수의 이름만 주고 실행하는건 JS의 몫이다.
가끔은 뭐가 클릭됐는지 어디가 클릭됐는지 등 정보를 알고 싶을때가 있다. 그럴때 JS는 단순히 함수를 실행시키기만 하는게 아니라
JS는 함수를 실행시키는 동시에 그 함수에 첫번째 인자로 object를 넣어줄 것이다. 그게 규칙이다.
그리고 이 object에는 방금 일어난 event에 대한 여러 정보가 담겨있다. 이건 JS가 우리한테 공짜로 주는 것이다.
방금 일어난 event에 대한 정보를 담은 이 object는 handleLinkClick을 위한 EventListener함수의 첫번째 인자로 주어지게 될 것이다.
우리는 공간만 만들고 받기만 하면 된다.

계산기를 만들었을때 처럼 우리는 argument를 받아줘야 한다.

전에는 SubmitEvent였는데 PointerEvent로 뜨는걸 볼 수 있다. (MouseEvent/ 브라우저에 따라 다름)
그리고 옆에 내가 클릭한 위치의 좌표를 보여주고 있는것도 확인할 수 있다. 
이건 엄청난 중요 정보다. 유저가 어디를 클릭했는지 알아야할 때가 있기 때문이다.
그리고 여기 유저가 스크린 상 클릭한 위치를 좌표로 제공하고 있다.
보다시피, 이벤트로부터 얻을 수 있는 다양한 정보가 존재하고 굉장히 다양한 이벤트들이 존재한다.
지금 우리는 기본동작을 안막고 있으니까 확인을 누르면 바로 이동하게 된다. 아직 원하는대로 안됐다.

우리가 해줄건, event.preventDefault()이다.
그리고 event의 내부를 봐보자

클릭해도 더이상 nomadcoders로 이동하지 않는다. 기본동작을 막고있기 때문이다. 이제 이해 될 것이다.
브라우저는 링크를 클릭할 때 해당 사이트로 이동하도록 설정되어 있는데 이 기본동작을 막아준 것이다.

내부를 보면 다양한 정보를 확인할 수 있다.
path를 보면 우리가 클릭할 때 무슨 일이 있었는지, 어디서 발생했는지 array로 보여주고 있다.
이게 이벤트를 활용하는 방법이고 preventDefault();를 사용하는 이유다.

가장 중요한건 addEventListener안에 있는 함수는 직접 실행하지 않았다는 것이다.

#4.4 Getting Username

이제 우리가 하고 싶은건 유저가 이름을 제출하면, form을 없애주는걸 하고 싶다.
이걸 구현하기 위한 방법
1,  HTML 요소 자체를 없애는것.
2, CSS로 숨기기
어떤 요소에게든 이 classname을 주면 그 요소를 숨기게 될 것이다.
단순히 hidden이라는 classname을 더해주면 된다.

우리는 유저가 이름을 form을 통해 제출했을 때, 기본동작은 막아주면서 내용은 기록하는것

이렇게 입력하고 테스트해보면 form은 사라졌지만 입력값은 console에 기록된걸 볼 수 있다.

이제 다른 요소를 추가해보자. 이 요소는 h1이고 내용은 비워둘거다. 비워둔 채로 둘거지만 h1이 될 것이다.
그리고 이 h1은 기본값으로 hidden이라는 class name을 갖게 될 것이다. 

새로고침하고 body를 확인해보면 form이 있고 h1도 있는데 h1은 숨겨져있는걸 볼 수 있다.
이제 할일은 form은 숨기고 h1은 표시되도록 하는 것이다.
하지만 h1에 표시할 텍스트가 있을 때만 표시되도록 할 것이다.
디시, 우리가 할 일은
기본동작은 실행되지 않도록 막아주고, hidden이라는 class name을 더해줘서 form을 숨기고, 유저의 이름을 변수로 저장해주고, 그 이름은 h1안에 넣어줄거다.

일단 greeting이란 id를 추가해줄 것이다.


그리고 다시 JS로 돌아와서 이 id를 찾아줄 것이다.

이럼 준비가 거의 다 됐다. 하나 빼먹은게 있다.

Css까지.
이러고 실행시켜보면 form이 숨겨지는걸 볼 수 있다.

element를 살펴보면

class=“hidden”이 추가됐고 h1 안에는 “Hello Nico”가 들어갔다.
잘 작동하는데 또 h1에서 hidden class 빼는걸 깜빡했다.

이건데 hidden을 2번 사용하고 있으니 const HIDDEN_CLASSNAME = “hidden 을 추가하자.

왜 이건 대문자로 쓰지??
이건 그냥 관습같은거다. 누군 좋아하고 누군 싫어하는.
일반적으로 string만 포함된 변수는 대문자로 표기하고 string을 저장하고 싶을때 사용한다.
그리고 이건 loginForm이나 loginInput처럼 중요한 정보를 담은게 아니라서 대문자로 작성한다.
이렇게 해주면 유저한테 인사할 수 있다.

HTML을 살펴보면 단순히 classname을 추가해주고 삭제하고 할 뿐이다.
물론 h1안에 텍스트를 추가하기 전에는 이 hidden class를 삭제할 수 없다.
하지만 보다시피 잘 작동한다.

짚고 넘어가야할 것이 있는데, JS를 살펴보면 string 두개의 조합이 있다.

지금 하고 있는건 두 개의 string을 합치는 거다. Hello 띄고 username. 이렇게 합치는 것도 하나의 방법이다.
근데 이건 효율적이지 못하다. 간격도 기억해야하고 +도 보기 안좋다.
대체하는건 ‘’이다. 우리가 전에 했던 방식 대신에 ‘Hello ${username}’;이다.
이 방법 모두 똑같은 동작을 수행할 것이다. 둘 다 Hello 다음에 한칸 띄우고 username 변수의 값을 표시해 줄거다.

후자의 방식이 더 최근 방식인데 얘는 2가지 규칙이 있다.
1, 만약 변수와 string을 결합하고 싶다면 또는 string안에 집어넣고 싶다면 ${변수명} 이렇게 표현하면 끝이다.
뒤에 뭘 추가해도 상관없고 이 부분만 JS가 변수값으로 바꿔줄 것이다.
2, 가장 중요한 규칙. 따옴표들 아니고 백틱이다. `` 이거. 
일반 따옴표란 ${}을 같이 사용하면, 변수값은 전혀 반영되지 않는다.
백틱을 써야 변수값이 string으로 입력될 것이다.

`` $ {} !!
이걸로 유저한테 인사하는 작업은 끝냈다.
근데 문제는 우리가 유저를 전혀 기억할 수 없다는 것이다. 새로고침 할때마다 새로 로그인해야한다.
새로고침할 때도 form을 볼 필요 없이 이름이 저장되어 있으면 좋겠다. 그걸 다음 강의에서 할거다.

#4.5 Saving Username

유저에게 매번 질문하기 번거롭기 때문에 value를 기억하는 방법을 배운다.
항상 그랬듯이 뭔가를 저장하는건 아주 많이 사용되는 기능이다. 유저의 이름이나 뭐가 되던간에.
예를 들어 유튜브에서 볼륨을 조절하고 새로고침하면 유튜브가 불륨값을 기억하는거.

우리는 유저를 기억하려고 한다. 이 작업 역시 흔히 하는 작업.
className을 추가하고 삭제하는거처럼 말이다. 그러니 아마 API가 존재할 것이다.
우리가 브라우저에 공짜로 뭔가를 기억할 수 있게 해주는 기능이 존재한다. 그 API의 이름은 local storage이다.
콘솔에 localStorage라고 입력하면 볼 수 있는데 이미 정의되어 있다.
아직 우리가 모르는 storage라는 걸 반환하고 있는데 중요한건 local storage가 존재한다는 것이다.
Local storage는 우리가 브라우저에 뭔가를 저장할 수 있게 해준다. 그래서 나중에 가져다 쓸 수도 있다.
Local storagedp 뭐가 들어있는지 보고 싶다면 개발자 도구를 이용하면 된다.

￼
여기 있는 것들 모두 다양한 방법으로 유저 정보를 저장할 수 있지만 그 중 local storage가 가장 다루기 쉽다.

￼
지금은 비어있는걸 확일할 수 있다. 하지만 나중에 이것저것 저장하기 시작하면 여기가 바뀌는걸 보게될 것이다.
Local storage API를 살펴보면 다양하고 멋진 method들을 보게될 것이다.
그 중 하나는 바로 setItem이다. 이걸 활용하면 local storage에 정보를 저장할 수 있다.
localStorage.setItem(‘myCat’, ’Tom’); 계속 무엇. 무엇 이런 형식을 보게 되는데, 계속 활용될 것이다.
중요한건 우리가 setItem을 활용할 수 있다는거고 어떻게 작동하는지 보자.

콘솔로가서 localStorage.setItem이라고 작성하고 우리가 저장할 값의 이름을 정해줄거다. 예를 들면 username. 그 다음에는 저장할 값을 적어줄거다. 예를들어 tak.

이 코드를 실행하면 우리의 DB에는 새로운 항목이 있다.

이런식으로. Username이다. 이제 우리는 우리가 원하는 값을 저장할 수 있게 됐다.
값을 저장하고 난 다음에는 당연히 그 값을 불러올 수도 있다.
localStorage.getItem(“username”)

저장한 값을 불러오는걸 볼 수 있다. 
필요한 경우 저장된 값을 지울 수도 있다.
localStorage.removeItem(“username”)
확인해보면 삭제된걸 확인할 수 있다.

마치 작은 미니 DB같은거다. 우리는 key와 value만 준비하면 된다. 이게 전부다.
이제 우리가 할일은 유저가 이름을 제출할 때 그걸 저장해주면 되는거다.

JS에서 localStorage.setItem을 적어준다. 우선 저장될 값의 이름(key)를 정해주고, 그 다음에는 값인 Username을 적어주면 된다.

이렇게 key: username, value: nico가 입력된걸 확인할 수 있다.

근데 여전히 이 form이 표시되고 있다.
이제 우리는 local storage에 username이 존재하는지 확인하고, form을 표시하지 않을 거다. 그런 경우 우리는 h1요소가 표시되도록 할거다.
만약 local storage에 유저정보가 없다면 form이 먼저 표시되도록 할거다.


#4.6 Loading Username

Local storage에 유저정보가 있으면 form을 보여주면 안된다.
우리는 H1 요소를 보여줘야 한다. 
이제 할 일은 local storage에 유저정보 유무를 확인하는 것이다.
username을 삭제하고 실행시켜보면 null 값을 결과로 받는 모습을 확인할 수 있다.
이게 우리가 원하는 것이다. Local storage에 유저 정보의 유무를 확인하고 싶기 때문이다.

만약 savedUsername의 값이 null인 경우에는 form을 보여줄거고 그 외의 경우는 greeting을 보여줄거다.

이렇게 로직이 정해졌다. 간단하다.
근데 username이 반복되고 있다. 저 값은 똑같아야하는데 오타가 날 수도 있다. 오타내놓고 눈치 못채고 있을 수도 있다.
이거처럼 string을 반복해서 사용하는 경우에 그리고 무조건 같은 경우여야할 때 전처럼 변수로 고정시켜줄 수 있다.
이건 매우 중요하다 왜냐면 이 string을 한번만 작성하는 것이 최고이기 때문이다.
만약 string을 작성하다가 오타가 나면 JS는 이걸 지적하지 않는다. 하지만 변수명이 오타가 나면, JS가 지적해준다.
본인이 생성한 string을 반복해서 사용하게 도ㅚㄹ 경우에는 앞서 만든 class name “hidden”이나 local storage key “username”처럼
이렇게 반복되는 string들은 대문자 변수로 저장해놓는 것이 좋은게 실수로 만들고 싶지 않은 string이라는 사실을 기억하고 상기시키기 좋다.

우리가 하고싶은 작업을 하려면 form이랑 greeting 모두 숨긴채로 시작해야될 것 같다.

HTML에는 있지만 화면에는 표시되지 않고 있는 상태이다.
이제 우리가 뭘 표시할지 선택할 수 있기 때문에 지금 할 부분은 정말 중요하다.

다시, savedUsername 값이 Null인 경우, 즉 local storage에 유저정보가 없을때,
우리는 loginForm.classList.remove(HIDDEN_CLASSNAME);하고 addEventListener를 추가하자.

만약 유저정보가 local storage에 없다면 local storage는 null값을 반환할거다.
그래서 만약 savedUsername값이 null이라면 form의 hidden class명을 지워줄거다.
왜냐하면 지금은 form이랑 h1모두 hidden이라는 class를 가지고 시작하기 때문이다.

보다시피 form은 표시되고 h1은 숨겨진 상태가 유지되고 있다. 왜냐하면 지금 local storage에는 유저정보가 없기 때문.
그럼 로그인을 하면 되겠지?

로그인을 클릭하면 이전이랑 똑같이 작동하는것을 볼 수 있다. 차이점은 이제 local storage에 유저정보가 저장되어 있다는 거다.
그럼 이제 새로고침하면 다시 작동해야되는데 아직 우리는 아무것도 하지 않고 있다.
이제 우리가 해야할 일은 greeting을 보여주는거다.
Greeting을 보여주기 위해서는 hidden class명을 제거해줘야 한다. greeting.classList.remove(HIDDEN_CLASSNAME);
새로고침하면 작동은 하고 있는걸 볼 수 있다. greeting에 이제 hidden class명은 없다. 하지만 greeting에 텍스트도 없다.
왜냐하면 그 텍스트는 우리가 추가해줘야하기 때문이다. greeting.innerText = `Hello ${savedUsername}`;
지금 존재하는건 savedUsername이니까 저렇게 작성해줘야 한다. 적고 둘이 순서도 바꿔주자
그리고 먼저 greeting 안에 텍스트를 추가하고 그런 다음 greeting에서 HIDDEN_CLASSNAME을 제거해줄거다.
￼
작동됐다!
이제 우린 유저정보를 기억하고 있다.
다시 확인해보자. Local storage에서 유저정보를 지우고 새로고침하면, 
￼
form이 표시됐다. 완벽하다!
하지만 아주 작은 문제점이 있다.
똑같은 동작을 2번 반복하고 있다는 것이다.
우린 greeting.innerText랑 greeting.classList.remove를 반복하고 있다.
그래서 어쩌면 이걸 함수로 만드는게 나을 수도 있다고 생각한다.

그럼 paintGreetings라는 함수를 만들어보자.
￼
이 작업을 수행할텐데, username은 argument에서 가져올거고 
원래 else에 있던 애들은 paintGreetings함수를 호출해주면 된다. 인자로 savedUsername 넣어주고.
￼
이렇게 해서 코드를 2줄 더 적게 적어줄 수 있다.

우리는 방금 username을 인자로 받는 함수를 만들었고 이건 우리가 해오던 일을 할거다.
greeting에 텍스트 Hello ${username}을 추가 후 hidden class명을 지워주는 일
하지만 우리가 함수를 호출하는 위치에 따라 유저정보는 다른 곳에서 오게 될거다.
예를 들면 local storage에 유저정보가 있으면 거기서 유저정보를 받아서 인자로 넣어줄거다.
만약 Local storage에 유저정보가 없다면, 우리는 form의 submit을 기다리고
form이 submit되면 우리는 input으로부터 유저정보를 받고,
input에서 받은 user를 가진 paintGreetings를 호출할거다.
코드를 좀더 정리해서 다듬었고 이게 끝이다.





